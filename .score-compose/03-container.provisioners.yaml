- uri: template://smtp
  type: smtp
  init: |
    serviceName: smtp
    randomPassword: {{ randAlphaNum 16 | quote }}
    domain: {{ dig "annotations" "compose.score.dev/domain" "example.com" .Metadata | quote }}
    publishPort: {{ dig "annotations" "compose.score.dev/publish-port" "25" .Metadata | quote }}
    submissionPort: {{ dig "annotations" "compose.score.dev/submission-port" "587" .Metadata | quote }}
    smtpUser: {{ dig "annotations" "compose.score.dev/username" "smtp_user" .Metadata | quote }}
  state: |
    host: {{ dig "serviceName" .Init.serviceName .State | quote }}
    externalHost: {{ dig "annotations" "compose.score.dev/external-host" "host.docker.internal" .Metadata | quote }}
    port: {{ dig "publishPort" .Init.publishPort .State | quote }}
    submissionPort: {{ dig "submissionPort" .Init.submissionPort .State | quote }}
    username: {{ dig "smtpUser" .Init.smtpUser .State | quote }}
    password: {{ dig "randomPassword" .Init.randomPassword .State | quote }}
  outputs: |
    host: {{ .State.host }}
    externalHost: {{ .State.externalHost }}
    port: {{ .State.port }}
    submissionPort: {{ .State.submissionPort }}
    username: {{ .State.username | quote }}
    password: {{ .State.password | quote }}
  volumes: |
    smtpdata:
      driver: local
    smtpconfig:
      driver: local
  services: |
    {{ .State.host }}:
      image: axllent/mailpit:latest
      container_name: {{ .State.host }}
      ports:
      - target: 1025
        published: {{ .State.port }}
      - target: 8025
        published: 8025
      - target: 1025
        published: {{ .State.submissionPort }}
      volumes:
      - type: volume
        source: smtpdata
        target: /data
      - type: volume
        source: smtpconfig
        target: /config
      restart: unless-stopped
      environment:
        MP_SMTP_AUTH_ACCEPT_ANY: "1"
        MP_SMTP_AUTH_ALLOW_INSECURE: "1"
  info_logs: |
    - "{{.Uid}}: Para conectar al SMTP:\n\
      Host interno (Docker): {{ .State.host }}\n\
      Host externo (host): {{ .State.externalHost }}\n\
      Puerto: {{ .State.port }} (SMTP), {{ .State.submissionPort }} (Submission)\n\
      Usuario: {{ .State.username }}@{{ .Init.domain }}\n\
      Contraseña: {{ .State.password }}\n\
        Ejemplo de conexión:\n\
        \topenssl s_client -starttls smtp -crlf -connect {{ .State.externalHost }}:{{ .State.submissionPort }} \
        -quiet"

- uri: template://pyroscope
  type: pyroscope
  init: |
    serviceName: pyroscope
    domain: {{ dig "annotations" "compose.score.dev/domain" "example.com" .Metadata | quote }}
    publishPort: {{ dig "annotations" "compose.score.dev/publish-port" "4040" .Metadata | quote }}
    dataRetention: {{ dig "annotations" "compose.score.dev/data-retention" "15d" .Metadata | quote }}
  state: |
    host: {{ dig "serviceName" .Init.serviceName .State | quote }}
    externalHost: {{ dig "annotations" "compose.score.dev/external-host" "host.docker.internal" .Metadata | quote }}
    port: {{ dig "publishPort" .Init.publishPort .State | quote }}
    dataRetention: {{ dig "dataRetention" .Init.dataRetention .State | quote }}
    webUrl: http://{{ dig "serviceName" .Init.serviceName .State }}:{{ dig "publishPort" .Init.publishPort .State }}
  outputs: |
    host: {{ .State.host }}
    externalHost: {{ .State.externalHost }}
    port: {{ .State.port }}
    webUrl: {{ .State.webUrl }}
    dataRetention: {{ .State.dataRetention }}
  volumes: |
    pyroscopedata:
      driver: local
  services: |
    {{ .State.host }}:
      image: pyroscope/pyroscope:latest
      container_name: {{ .State.host }}
      ports:
      - target: 4040
        published: {{ .State.port }}
      volumes:
      - type: volume
        source: pyroscopedata
        target: /var/lib/pyroscope
      restart: unless-stopped
      environment:
        PYROSCOPE_LOG_LEVEL: info
        PYROSCOPE_STORAGE_PATH: /var/lib/pyroscope
        PYROSCOPE_API_BIND_ADDR: 0.0.0.0:4040
        PYROSCOPE_DATA_RETENTION: {{ .State.dataRetention }}
      command:
      - "server"
  info_logs: |
    - "{{.Uid}}: Pyroscope configurado exitosamente:\n\
      URL interna: {{ .State.webUrl }}\n\
      Host interno (Docker): {{ .State.host }}\n\
      Host externo (host): {{ .State.externalHost }}\n\
        Puerto: {{ .State.port }}\n\
        Retención de datos: {{ .State.dataRetention }}\n\
        \n\
      Para enviar perfiles desde tu aplicación:\n\
        \tEndpoint interno: http://{{ .State.host }}:{{ .State.port }}\n\
        \tEndpoint externo: http://{{ .State.externalHost }}:{{ .State.port }}\n\
        \n\
        Ejemplo de configuración para aplicaciones:\n\
        \tPython: pyroscope.configure(application_name='mi-app', server_address='http://{{ .State.externalHost }}:{{ .State.port }}')\n\
        \tGo: pyroscope.Start(pyroscope.Config{ApplicationName: 'mi-app', ServerAddress: 'http://{{ .State.externalHost }}:{{ .State.port }}'})\n\
        \tJava: -javaagent:pyroscope.jar=server=http://{{ .State.externalHost }}:{{ .State.port }},applicationName=mi-app"

- uri: template://zincsearch
  type: elasticsearch
  description: Provisions a ZincSearch instance (Elasticsearch-compatible ingest) manteniendo outputs análogos.
  init: |
    serviceName: zincsearch
    randomPassword: {{ randAlphaNum 16 | quote }}
    username: {{ dig "annotations" "compose.score.dev/username" "admin" .Metadata | quote }}
    sk: default-provisioners-elasticsearch-instance
    publishPort: {{ dig "annotations" "compose.score.dev/publish-port" "9200" .Metadata | quote }}
  state: |
    username: {{ dig "username" .Init.username .State | quote }}
    password: {{ dig "password" .Init.randomPassword .State | quote }}
    host: {{ dig "host" .Init.serviceName .State | quote }}
    externalHost: {{ dig "annotations" "compose.score.dev/external-host" "host.docker.internal" .Metadata | quote }}
  outputs: |
    host: {{ .State.host }}
    externalHost: {{ .State.externalHost }}
    port: {{ .Init.publishPort }}
    username: {{ .State.username | quote }}
    password: {{ .State.password | quote }}
  volumes: |
    zincdata:
      driver: local
  services: |
    {{ .State.host }}:
      image: public.ecr.aws/zinclabs/zincsearch:latest
      container_name: {{ .State.host }}
      ports:
      - target: 4080
        published: {{ .Init.publishPort }}
      volumes:
      - type: volume
        source: zincdata
        target: /data
      restart: unless-stopped
      environment:
        ZINC_FIRST_ADMIN_USER: {{ .State.username }}
        ZINC_FIRST_ADMIN_PASSWORD: {{ .State.password }}
        ZINC_DATA_PATH: /data
  info_logs: |
    - "{{.Uid}}: Para conectar a ZincSearch (sustituto de Elasticsearch):\n\
      Host interno (Docker): {{ .State.host }}\n\
      Host externo (host): {{ .State.externalHost }}\n\
      Puerto: {{ .Init.publishPort }}\n\
      Usuario: {{ .State.username }}\n\
      Contraseña: {{ .State.password }}\n\
      Ejemplo (ingesta vía API compatible):\n\
        \tcurl -u {{ .State.username }}:{{ .State.password }} http://{{ .State.externalHost }}:{{ .Init.publishPort }}/api/\n\
      UI web: http://{{ .State.externalHost }}:{{ .Init.publishPort }}"
  expected_outputs:
    - host
    - externalHost
    - port
    - username
    - password

# The default AMQP provisioner provides a simple rabbitmq instance with default configuration and plugins. Variation to export ports to host.
- uri: template://default-provisioners/rabbitmq
  type: amqp
  description: Provisions a dedicated RabbitMQ vhost on a shared instance.
  init: |
    randomServiceName: rabbitmq-{{ randAlphaNum 6 }}
    randomVHost: vhost-{{ randAlpha 8 }}
    randomUsername: user-{{ randAlpha 8 }}
    randomPassword: {{ randAlphaNum 16 | quote }}
    sk: default-provisioners-rabbitmq
    publishPort: {{ dig "annotations" "compose.score.dev/publish-port" "0" .Metadata | atoi }}
    publishManagementPort: {{ dig "annotations" "compose.score.dev/publish-management-port" "0" .Metadata | atoi }}
  state: |
    internalHost: {{ dig .Init.sk "instanceServiceName" "" .Shared | quote }}
    externalHost: {{ dig "annotations" "compose.score.dev/external-host" "host.docker.internal" .Metadata | quote }}
    vhost: {{ dig "vhost" .Init.randomVHost .State | quote }}
    username: {{ dig "username" .Init.randomUsername .State | quote }}
    password: {{ dig "password" .Init.randomPassword .State | quote }}
  outputs: |
    host: {{ .State.internalHost }}
    externalHost: {{ .State.externalHost }}
    port: 5672
    vhost: {{ .State.vhost }}
    username: {{ .State.username }}
    password: {{ .State.password }}
  shared: |
    {{ .Init.sk }}:
      instanceServiceName: {{ dig .Init.sk "instanceServiceName" .Init.randomServiceName .Shared | quote }}
      instanceErlangCookie: {{ dig .Init.sk "instanceErlangCookie" (randAlpha 20) .Shared }}
      {{ $publishPorts := (list) }}
      {{ if ne .Init.publishPort 0 }}{{ $publishPorts = (append $publishPorts (dict "target" 5672 "published" .Init.publishPort)) }}{{ end }}
      {{ $x := (dig "annotations" "compose.score.dev/publish-management-port" "0" .Metadata | atoi) }}
      {{ if ne .Init.publishManagementPort 0 }}{{ $publishPorts = (append $publishPorts (dict "target" 15672 "published" .Init.publishManagementPort)) }}{{ end }}
      publishPorts: {{ $publishPorts | toJson }}
  volumes: |
    {{ .State.internalHost }}-data:
      driver: local
  files: |
    {{ .State.internalHost }}-db-scripts/{{ .State.vhost }}.sh: |
      rabbitmqctl list_vhosts | grep {{ .State.vhost }} || rabbitmqctl add_vhost {{ .State.vhost }}
      rabbitmqctl list_users | grep {{ .State.username }} || rabbitmqctl add_user {{ .State.username }} {{ .State.password }}
      rabbitmqctl set_user_tags {{ .State.username }} administrator
      rabbitmqctl set_permissions -p {{ .State.vhost }} {{ .State.username }} ".*" ".*" ".*"
      rabbitmqctl set_topic_permissions -p {{ .State.vhost }} {{ .State.username }} ".*" ".*" ".*"
  services: |
    {{ .State.internalHost }}:
      image: mirror.gcr.io/rabbitmq:3-management-alpine
      restart: always
      environment:
        RABBITMQ_ERLANG_COOKIE: {{ dig .Init.sk "instanceErlangCookie" "" .Shared }}
        RABBITMQ_DEFAULT_USER: guest
        RABBITMQ_DEFAULT_PASS: guest
      {{ $port := dig .Init.sk "publishPort" 0 .Shared }}
      {{ $mgmt := dig .Init.sk "publishManagementPort" 0 .Shared }}
      {{ if or (ne $port 0) (ne $mgmt 0) }}
      ports:
      {{ if ne $port 0 }}
      - target: 5672
        published: {{ $port }}
      {{ end }}
      {{ if ne $mgmt 0 }}
      - target: 15672
        published: {{ $mgmt }}
      {{ end }}
      {{ end }}
      volumes:
      - type: volume
        source: {{ .State.internalHost }}-data
        target: /var/lib/rabbitmq
      healthcheck:
        test: ["CMD-SHELL", "rabbitmq-diagnostics -q check_port_connectivity"]
        interval: 2s
        timeout: 5s
        retries: 15
    {{ .State.internalHost }}-init:
      image: mirror.gcr.io/rabbitmq:3-management-alpine
      entrypoint: ["/bin/sh"]
      environment:
        RABBITMQ_ERLANG_COOKIE: {{ dig .Init.sk "instanceErlangCookie" "" .Shared }}
      command:
      - "-c"
      - |
        set -exu
        for s in /db-scripts/*.sh; do source $$s; done
      depends_on:
        {{ .State.internalHost }}:
          condition: service_healthy
          restart: true
      labels:
        dev.score.compose.labels.is-init-container: "true"
      network_mode: service:{{ .State.internalHost }}
      volumes:
      - type: bind
        source: {{ .MountsDirectory }}/{{ .State.internalHost }}-db-scripts
        target: /db-scripts
  info_logs: |
    {{ if ne .Init.publishManagementPort 0 }}  
    - "{{.Uid}}: RabbitMQ UI disponible en \"http://{{ .State.externalHost }}:{{ .Init.publishManagementPort }}\""
    {{ end }}
  expected_outputs:
    - host
    - externalHost
    - port
    - vhost
    - username
    - password